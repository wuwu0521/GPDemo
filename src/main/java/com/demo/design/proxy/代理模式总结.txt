思考：为什么JDK动态代理中要求目标类实现的接口数量不能超过65535个？
java Unicode版本对应于UCS-2，使用16位的编码空间，因此最大能表示65535个字符。

jdk动态代理
1、拿到被代理类的引用，并且获取它的所有的接口(反射获 取)。
2、JDK Proxy类重新生成一个新的类，实现了被代理类所有 接口的方法。
3、动态生成Java代码，把增强逻辑加入到新生成代码中。
4、编译生成新的Java代码的class文件。
5、加载并重新运行新的class，得到类就是全新类。

cglib动态代理
1、生成代理类的子类，相关三个类文件
2、无法代理final修饰的类
3、被代理的类接口不能超过65535


CGLib和JDK动态代理对比
1.JDK动态代理是实现了被代理对象的接口，CGLib是继承了 被代理对象。
2.JDK和CGLib都是在运行期生成字节码，JDK是直接写Class 字节码，CGLib使用ASM框架写Class字节码，Cglib代理实现 更复杂，生成代理类比JDK效率低。
3.JDK调用代理方法，是通过反射机制调用，CGLib是通过 FastClass机制直接调用方法，CGLib执行效率更高。

代理模式的优点
1、代理模式能将代理对象与真实被调用的目标对象分离。
2、一定程度上降低了系统的耦合程度，易于扩展。
3、代理可以起到保护目标对象的作用。
4、增强目标对象的职责

代理模式的缺点
1、代理模式会造成系统设计中类的数目增加
2、在客户端和目标对象之间增加了一个代理对象，会造成请求处
3、理速度变慢。
4、增加了系统的复杂度。

Spring中的代理选择原则
1、当Bean有实现接口时，Spring就会用JDK的动态代理。
2、当Bean没有实现接口时，Spring选择CGLib。
3、Spring可以通过配置强制使用CGLib，只需在Spring的配 置文件中加入如下代码:
<aop:aspectj-autoproxy proxy-target-class="true"/>